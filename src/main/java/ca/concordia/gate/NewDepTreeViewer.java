package ca.concordia.gate;

import gate.Annotation;
import gate.AnnotationSet;
import gate.Document;
import gate.creole.AbstractVisualResource;
import gate.creole.AnnotationVisualResource;
import gate.creole.metadata.CreoleResource;
import gate.util.GateException;
import guru.nidi.graphviz.attribute.Color;
import guru.nidi.graphviz.attribute.Font;
import guru.nidi.graphviz.attribute.Style;
import guru.nidi.graphviz.attribute.Label;
import guru.nidi.graphviz.engine.Format;
import guru.nidi.graphviz.engine.Graphviz;
import guru.nidi.graphviz.model.Graph;
import guru.nidi.graphviz.model.Node;

import javax.imageio.ImageIO;
import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static guru.nidi.graphviz.model.Factory.graph;
import static guru.nidi.graphviz.model.Factory.node;
import static guru.nidi.graphviz.model.Link.to;

@CreoleResource(name = "Dependency Tree Viewer 1", comment = "Viewer for dependency trees generated by a parser.", helpURL = "http://gate.ac.uk/userguide/sec:parsers:supple:treeviewer", annotationTypeDisplayed = "Sentence")
public class NewDepTreeViewer extends AbstractVisualResource
        implements Scrollable, ActionListener, MouseListener,
        AnnotationVisualResource {
    private BufferedImage image;

    // number of pixels to be used as increment by scroller
    protected int maxUnitIncrement = 10;
    private Annotation utterance;
    private AnnotationSet currentSet;
    private Document document;

    @Override
    public Dimension getPreferredScrollableViewportSize() {
        return getPreferredSize();
    }

    @Override
    public int getScrollableUnitIncrement(Rectangle visibleRect, int orientation, int direction) {
        return maxUnitIncrement;
    }

    @Override
    public int getScrollableBlockIncrement(Rectangle visibleRect, int orientation, int direction) {
        if (orientation == SwingConstants.HORIZONTAL)
            return visibleRect.width - maxUnitIncrement;
        else
            return visibleRect.height - maxUnitIncrement;
    }

    @Override
    public boolean getScrollableTracksViewportWidth() {
        return false;
    }

    @Override
    public boolean getScrollableTracksViewportHeight() {
        return false;
    }

    public NewDepTreeViewer() {
        System.out.println("howdy do");
    }

    @Override
    public void okAction() throws GateException {

    }

    @Override
    public void cancelAction() throws GateException {

    }

    @Override
    public boolean supportsCancel() {
        return false;
    }

    @Override
    public boolean canDisplayAnnotationType(String s) {
        return false;
    }

    @Override
    public void editAnnotation(Annotation ann, AnnotationSet set) {
        if (ann == null || set == null) return;
        this.removeAll();
        utterance = ann;
        currentSet = set;
        AnnotationSet allTokens = currentSet.get("Token");
        AnnotationSet sentenceTokens = allTokens.get(utterance.getStartNode().getOffset(),
                utterance.getEndNode().getOffset());
        Map<Integer, Node> graphNodes = new HashMap<>();
        Map<String, Integer> wordCounts = new HashMap<>();
        Graph g = graph("depParseTree").directed();
        for (Annotation tokenAno: sentenceTokens) {
            String word = (String)tokenAno.getFeatures().get("string");
            int count = 0;
            if (wordCounts.containsKey(word)) {
                count = wordCounts.get(word);
            }
            wordCounts.put(word, count + 1);
            graphNodes.put(tokenAno.getId(), node(tokenAno.getId() + "").with(Label.of(word)));
        }
        for (Annotation tokenAno : sentenceTokens) {
            List<DependencyRelation> dependencies = (List<DependencyRelation>)tokenAno.getFeatures().get("dependencies");
            if (dependencies != null) {
                Node currNode = graphNodes.get(tokenAno.getId());
                for (int i = 0; i < dependencies.size(); i++) {
                    DependencyRelation dep = dependencies.get(i);
                    Integer depID = dep.getTargetId();
                    String depType = dep.getType();
                    currNode = currNode.link(to(graphNodes.get(depID)).with(Style.SOLID, Label.of(depType), Color.BLACK, Font.size(10)));
                }
                g = g.with(currNode);
            }
        }
        BufferedImage myPicture = null;
        try {
            myPicture = ImageIO.read(Graphviz.fromGraph(g).render(Format.PNG).toFile(new File("example/ex1.png")));
        } catch (IOException e) {
            e.printStackTrace();
        }
        assert myPicture != null;
        JLabel picLabel = new JLabel(new ImageIcon(myPicture));
        add(picLabel);
        this.setVisible(true);
    }

    @Override
    public boolean editingFinished() {
        System.out.println("editing finished");
        return false;
    }

    @Override
    public boolean isActive() {
        return false;
    }

    @Override
    public Annotation getAnnotationCurrentlyEdited() {
        return null;
    }

    @Override
    public AnnotationSet getAnnotationSetCurrentlyEdited() {
        return null;
    }

    @Override
    public void actionPerformed(ActionEvent e) {

    }

    @Override
    public void mouseClicked(MouseEvent e) {

    }

    @Override
    public void mousePressed(MouseEvent e) {

    }

    @Override
    public void mouseReleased(MouseEvent e) {

    }

    @Override
    public void mouseEntered(MouseEvent e) {

    }

    @Override
    public void mouseExited(MouseEvent e) {

    }
}
